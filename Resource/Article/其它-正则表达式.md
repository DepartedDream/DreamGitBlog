# 什么是正则表达式

正则表达式就是记录文本规则的代码。

# 元字符

元字符表示一类
语法|说明
--|--
.|匹配除换行符以外的任意字符
\w|匹配字母或数字或下划线或汉字
\s|匹配任意的空白符
\d|匹配数字
\b|匹配字符和符号间的隐式位置
^|匹配字符串(即整个文本)的开始
$|匹配字符串(即整个文本)的结束

# 字符转义

如果你要查找的字符和元字符相同，可以使用转义符号\注释。

# 限定符

表示重复的次数
语法|说明
--|--
*|重复零次或更多次
+|重复一次或更多次
?|重复零次或一次
{n}|重复n次
{n,}|重复n次或更多次
{n,m}|重复n到m次

# 字符类

```
[a-z0-9A-Z]=\w
[0-9]=\d
```

# 分枝条件

表示匹配的多种情况
exp1|exp2|exp3 表示匹配表达式1,2,3中任意一个的内容

# 反义

有时需要查找不属于某个能简单定义的字符类的字符。
语法|说明
--|--
\W|匹配任意不是字母，数字，下划线，汉字的字符
\S|匹配任意不是空白符的字符
\D|匹配任意非数字的字符
\B|匹配不是单词开头或结束的位置
[^x]|匹配除了x以外的任意字符
[^aeiou]|匹配除了aeiou这几个字母以外的任意字符  

# 分组

分组能够使你给表达式加上限定符  
语法:(exp)

## 分组命名

语法:(?'组名'exp)  
语法:(?<组名>exp)

## 后向引用

分组引用允许你使用前面的表达式分组
\分组名
代表使用该分组名匹配的文本

# 零宽断言
零宽度:表达式不消耗任何字符
正:匹配表达式
负:不匹配表达式
预测先行:查找内容+预测内容
回顾后发:回顾内容+查找内容
名称|语法
--|--
零宽度正预测先行断言|(?=exp)
零宽度正回顾后发断言|(?<=exp)
零宽度负预测先行断言|(?!exp)
零宽度负回顾后发断言|(?<!exp）

# 贪婪与懒惰
## 贪婪匹配

当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符，被称为贪婪匹配

## 懒惰匹配

懒惰模式即匹配尽可能少的字符，限定符都可以通过加?转化为懒惰匹配模式
语法|说明
--|--
*?|重复任意次，但尽可能少重复
+?|重复1次或更多次，但尽可能少重复
??|重复0次或1次，但尽可能少重复
{n,m}?|重复n到m次，但尽可能少重复
{n,}?|重复n次以上，但尽可能少重复

# 尚未详细讨论的语法

语法|说明
--|--
\a|报警字符(打印它的效果是电脑嘀一声)
\b|通常是单词分界位置，但如果在字符类里使用代表退格
\t|制表符，Tab
\r|回车
\v|竖向制表符
\f|换页符
\n|换行符
\e|Escape
\0nn|ASCII代码中八进制代码为nn的字符
\xnn|ASCII代码中十六进制代码为nn的字符
\unnnn|Unicode代码中十六进制代码为nnnn的字符
\cN|ASCII控制字符。比如\cC代表Ctrl+C
\A|字符串开头(类似^，但不受处理多行选项的影响)
\Z|字符串结尾或行尾(不受处理多行选项的影响)
\z|字符串结尾(类似$，但不受处理多行选项的影响)
\G|当前搜索的开头
\p{name}|Unicode中命名为name的字符类，例如\p{IsGreek}
(?>exp)|贪婪子表达式
(?<x>-<y>exp)|平衡组
(?im-nsx:exp)|在子表达式exp中改变处理选项
(?im-nsx)|为表达式后面的部分改变处理选项
(?(exp)yes\|no)|把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no
(?(exp)yes)|同上，只是使用空表达式作为no
(?(name)yes\|no)|如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no
(?(name)yes)|同上，只是使用空表达式作为no  

# 正则表达式练习题
```
匹配整数或者小数（包括正数和负数）
-?\b\d+(\.\d+)?\b
长度为8-10位的用户密码 ： 包含数字字母下划线
\w{8,10}
匹配验证码：4位数字字母组成的
[0-9A-Ba-b]{4}
```


正则表达式中双引号、单引号的表示 

  知道正则表达式中用\u4e00-\u9fa5匹配汉字， 
  知道用\d匹配数字，\w匹配单词,\n换行……，可用什么匹配双引号呢" 
  有人用\"  来匹配双引号，或则用\'''匹配，可这只能在C#中才能用吧。偶然一天，发现如下方法求得了正则表达式中双引号的值. 

第一步，求出字符的asc码。 
第二步,把该asc码转换为4位的16进制数，位数不够者，前面加0，比如asc(")=34 
(34)10=(22)16   然后22  to  0022 
第三步，前面加\u,如 \u0022. 
第四步，拿去匹配吧。 
    我测试了，可以用，但不知道其他字符怎么样，这纯粹是自己偶然的一个想法，不能保证完全正确，请在用时自行测试。 


[正则表达式中双引号、单引号的表示](https://blog.csdn.net/lonelyenvoy/article/details/52249983)
[转载](https://deerchao.cn/tutorials/regex/regex.htm#top)